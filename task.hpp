/*
 * task.hpp
 *
 * \date 14/mag/2010
 * \author Daniele De Sensi (d.desensi.software@gmail.com)
 * =========================================================================
 *  Copyright (C) 2010-2014, Daniele De Sensi (d.desensi.software@gmail.com)
 *
 *  This file is part of Peafowl.
 *
 *  Peafowl is free software: you can redistribute it and/or
 *  modify it under the terms of the Lesser GNU General Public
 *  License as published by the Free Software Foundation, either
 *  version 3 of the License, or (at your option) any later version.

 *  Peafowl is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  Lesser GNU General Public License for more details.
 *
 *  You should have received a copy of the Lesser GNU General Public
 *  License along with Peafowl.
 *  If not, see <http://www.gnu.org/licenses/>.
 *
 * =========================================================================
 *
 * This file contains the definition of the task passed by the stages of the pipeline.
 */

#ifndef TASK_HPP_
#define TASK_HPP_
#include "flow.hpp"
#include <ff/squeue.hpp>
#include <iostream>


/**
 * The task generated by the first stage of the pipeline.
 */
class Task{
private:
    uint numWorkers;    ///<Number of workers of the pipeline.
    ff::squeue<hashElement>
        **flowsToAdd,///< A list of flows to add.
        *flowsToExport;///< A list of flows to export.
    bool eof; ///< True if the eof of a .pcap file is arrived.
        /**
      * The timestamp will be taken per task instead of per packet.
      * In this way we avoid the overhead due to an huge number of call of "time(NULL)".
          * Moreover, such that the packets belonging to the same task will be captured in
      * very short time between each other (because the read is non blocking),
          * the timestamps of these packets will be equal.
          */
        time_t timestamp;
public:
    /**
     * Constructor of the task.
     * \param numWorkers Number of workers of the pipeline.
     */
    inline Task(uint numWorkers):numWorkers(numWorkers),eof(false){
        flowsToAdd=new ff::squeue<hashElement>*[numWorkers];
        for(uint i=0; i<numWorkers; i++)
            flowsToAdd[i]=new ff::squeue<hashElement>;
        flowsToExport=new ff::squeue<hashElement>;
    }

    /**
     * Denstructor of the task.
     */
    inline ~Task(){
        if(flowsToExport!=NULL) delete flowsToExport;
        if(flowsToAdd!=NULL){
            for(uint i=0; i<numWorkers; i++)
                delete flowsToAdd[i];
            delete[] flowsToAdd;
        }
    }

        /**
      * Sets the timestamp of the task.
      * \param t The timestamp.
          */
        inline void setTimestamp(time_t t){
            timestamp=t;
    }

        /**
      * Returns the timestamp of the task.
          * \return The timestamp of the task.
          */
        inline time_t getTimestamp(){
                return timestamp;
        }
    /**
     * Adds an hashElement to the list of flows to export.
     * \param h The hashElement.
     */
    inline void addFlowToExport(hashElement& h){
            flowsToExport->push_back(h);
    }

    /**
     * Returns a pointer to the list of flows to export.
     * \return A pointer to the list of flows to export.
     */
    inline ff::squeue<hashElement>* getFlowsToExport(){
        return flowsToExport;
    }

    /**
     * Returns a pointer to the list of the flows to add.
     * \return A pointer to the list of the flows to add.
     */
    inline ff::squeue<hashElement>* getFlowsToAdd(const int i){
        return flowsToAdd[i];
    }

    /**
     * Adds the hashElement h for the i-th worker.
     * \param h The hashElement to add.
     * \param i The worker that have to add the flow.
     */
    inline void setFlowToAdd(hashElement& h, const int i){
        flowsToAdd[i]->push_back(h);
    }

    /**Sets EOF. **/
    inline void setEof(){eof=true;}

    /**Resets EOF.**/
    inline void resetEof(){eof=false;}

    /**
     * Returns true if EOF of a .pcap file is arrived.
     * \return True if EOF is arrived, otherwise returns false.
     */
    inline bool isEof(){return eof;}

    /**
     * Returns the number of workers.
     * \return The number of workers.
     */
    inline int getNumWorkers(){
        return numWorkers;
    }
};

#endif /* TASK_HPP_ */
